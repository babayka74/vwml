options {
	language=__java__ {
  		package = "com.win.strategy.battle.vwml.model"
  		path = "c:\var\vwml/battleModel3B/src"
  		author = "Win Interactive"
		project_name = "battleModel3B"
  		description = "Strategy battle model 3B"
		beyond {
			fringe communication ias (
				out ias "com.win.game.model.fringe.gate.async.console.AsyncConsole"
				in ias "com.win.game.model.fringe.gate.async.console.AsyncConsole"
				// outchannel ias "com.win.strategy.battle.vwml.gate.BMVWMLMoveBehaviorGate"
			)
			fringe services ias (
				math ias "com.vw.lang.beyond.java.fringe.gate.math.Math"
				graph ias "com.win.game.model.fringe.gate.algorithm.graphloader.GraphLoader"
			)
		}
	}
	conflictring {
		"{MagicWorld.Manager}.PropagateCommand.LockQueue" conflicts (
			"{MagicWorld.Player}.PlayerLifeStep.(Stop false).(emptyQ false).LockQueue"
		)
          	"[MagicWorld.Player].MagicWorld.Characters.Unit.UnitAsDefender.Create.LockDefenders" conflicts (
			"[MagicWorld.Characters.Unit].MagicWorld.Characters.Attacker.ActivityStrategy.Actions.Attack.LockDefenders"
			"[MagicWorld.Characters.Unit].MagicWorld.Characters.Unit.UnitAsDefender.Destroy.LockDefenders"
		)
		"{MagicWorld.Player}.StopAllUnits.CheckForUnitsCompletition.Check.WaitForUnitsCompletitionLock" conflicts (
			"[MagicWorld.Characters.Unit].MagicWorld.Characters.Unit.UnitAsDefender.Destroy.LockDefenders"
			"[MagicWorld.Characters.Unit].MagicWorld.Characters.Unit.UnitAsAttacker.Destroy.LockAttackers"
		)
		"[MagicWorld.Characters.Unit].MagicWorld.Player.UnitsStateSetLocker" conflicts (
			"[MagicWorld.Characters.Unit].MagicWorld.Player.UnitsStateSetLocker"
		)
		"[MagicWorld.Characters.Unit].MagicWorld.PathFinder.UpdateUnitsSharedPath.RecalculatePathToAttacker.LockSharedStates" conflicts (
			"[MagicWorld.Characters.Unit].MagicWorld.Player.UnitsStateSetLocker"
		)
		"[MagicWorld.Characters.Unit].MagicWorld.Services.SignalUnit.LockUnitCommandQueue" conflicts (
			"{MagicWorld.Player}.PropagateCommandToUnit.LockUnitCommandQueue"
			"[MagicWorld.Player].MagicWorld.Services.SignalUnit.LockUnitCommandQueue"
			"{MagicWorld.Characters.Unit}.UnitLifeStep.(Stop false).(emptyQ false).LockUnitCommandQueue"
		)
		"{MagicWorld.Characters.Unit}.UnitLifeStep.(Stop false).(emptyQ false).LockUnitCommandQueue" conflicts (
			"{MagicWorld.Player}.PropagateCommandToUnit.LockUnitCommandQueue"
		)
		"[MagicWorld.Characters.Unit].MagicWorld.Characters.Defender.ActivityStrategy.Actions.Defence.Observe.LockAttackers" conflicts (
			"[MagicWorld.Player].MagicWorld.Characters.Unit.UnitAsAttacker.Create.LockAttackers"
			"[MagicWorld.Player].MagicWorld.Characters.Unit.UnitAsAttacker.Destroy.LockAttackers"
		)
		"{MagicWorld.Characters.Unit}.UnitAsAttacker.Destroy.LockAttackers" conflicts (
			"{MagicWorld.Characters.Unit}.UnitAsAttacker.Destroy.LockAttackers"
		)
	}
}

include "../algorithms/DpfAPEx/DpfAPEx.vwml"
include "attacker.vwml"
include "defender.vwml"

module battleModel3B {
	Ew ias (
		Maze ias (
			Attack ias (
				/* nodes marked as 'attacking' */
				Nodes ias ();
			);
			Defence ias (
				/* nodes marked as 'defence' */
				Nodes ias ();
			);
			/* all maze's nodes */
			Nodes ias ();
			MazePrototype ias (
				Stg ias nil;
				Ctx ias nil;
				(Node ($~ 0) Get)^
				(LinkedNodes ($~ 1) Get)^
				(Node~ Ctx~ true) Context
				(Node~ LinkedNodes~)^
				(Stg~ (Stg~~ (Node~)) Join)^
				((Connecting Node~ with LinkedNodes~ and list of nodes Stg~~ on context Ctx~) Ew.Output~) Do
			);
			BuildMainZone ias (
				(MazePrototype.Stg Nodes)^
				(MazePrototype.Ctx Ew.Maze)^
				MazePrototype~ Exe
			);
			// attack firezones
			BuildAttackFireZone ias (
				(MazePrototype.Stg Attack.Nodes)^
				(MazePrototype.Ctx Ew.Maze.Attack)^
				MazePrototype~ Exe
			);
			// defence firezone
			BuildDefenceFireZone ias (
				(MazePrototype.Stg Defence.Nodes)^
				(MazePrototype.Ctx Ew.Maze.Defence)^
				MazePrototype~ Exe
			);
			Initial ias (	(battleField BuildMainZone Ew.Maze)
					(attackFireZoneField BuildAttackFireZone Ew.Maze.Attack)  
					(defenceFireZoneField BuildDefenceFireZone Ew.Maze.Defence)
				);
			MazeBuilder ias (((($~ 0) Get) Ew.LoadGraph~ ($~ 2) Get) Do ($~ 1) Get ~) ForEach;
			/* builds: battlefield, atackers' firezone, defenders' firezone */
			(Initial~ MazeBuilder~) ForEach
		);

		TargetsToBeDestroyed ias ((17 10));
		ConfiguredNumOfRequestedSteps ias 4;
		Input ias communication.in.read;
		Output ias communication.in.write;
		// MoveUnit ias communication.outchannel.move;
		IncIteration ias services.math.inc;
		DecValue ias services.math.dec;
		LoadGraph ias services.graph.load;
	);
	MagicWorld ias (
		StopTheWorld ias false;
		PathFinder ias (
			PlayerId ias nil;
			FromUnit ias nil;
			ToUnit ias nil;
			/* removes path, created from last attacker's position (state), from units' shared path (UnitsStateSet) */
			UpdateUnitsSharedPath ias (
				RecalculatePathToAttacker ias (
					TResult ias doNothing;
					TTargetDestroyed ias doNothing;
					(TSeqStates ())^
					(TUnitsStateState ())^
					(TRequestedSteps ())^
					(TTargetsToBeDestroyed ())^
					(TRequestedSteps ())^
					(TNumOfRequestedSteps 1000)^
					(TNoSteps false)^
					(Characters)->(Unit $~)->GetCurrentPosition~ Exe
					(TGoals ((Characters)->(Unit $~)->CurrentPosition~))^
					(Characters)->(Unit FromUnit~)->GetCurrentPosition~ Exe
					(TState (Characters)->(Unit FromUnit~)->CurrentPosition~)^
					/* calculates path to another attacker; this path is substracted from shared units' path */
					((LLLLLL TState~ TGoals~ (Characters)->(Unit FromUnit~)->CurrentPosition~) Ew.Output~) Do
					((TGoals
						TTargetsToBeDestroyed
						TState
						TUnitsStateState
						TSeqStates
						TResult
						TTargetDestroyed
						Ew.DecValue
						TRequestedSteps
						TNumOfRequestedSteps
						TNoSteps                     	
						FromUnit
						true) (DpfSearchMkAParallelEx FromUnit~)~) CallP
					((MMMMM) Ew.Output~) Do
					/* removes from shared path */
					LockSharedStates [
						((Player PlayerId~)->UnitsStateSet ((Player PlayerId~)->UnitsStateSet~ TRequestedSteps~) Substruct)^
						((Movement to attacker $~ is TRequestedSteps~ and new shared movement is (Player PlayerId~)->UnitsStateSet~) Ew.Output~) Do
					LockSharedStates ]
				);
				UpdatePath ias (
					(Ignore true) ias doNothing;
					(Ignore false) ias RecalculatePathToAttacker~ Exe;
					(Ignore ($~ AttackedAttacker~) Ident)~ Exe
				);
				((Player PlayerId~)->(Units)->Attackers~ UpdatePath~) ForEach
			);
		);
		Services ias (
			SignalUnit ias (
				PlayerId ias nil;
				To ias nil;
				CommandId ias nil;
				CommandParams ias nil;
				LockUnitCommandQueue [
					((Characters)->(Unit To~)->CommandQueue
						((Characters)->(Unit To~)->CommandQueue~ ((PlayerId~ CommandId~ To~ CommandParams~))) Join
					)^
				LockUnitCommandQueue ]
			);
			PositionChecker ias (
				Init ias doNothing;
				CheckPosition ias (
					(RightPosition true) ias (
						(PosToBeSet~ PosToBeChecked~)^
						(PosToBeChecked~ Ew.Maze true) Context
					);
					(RightPosition false) ias (
						(PosToBeSet~ nil)^
						((The pos PosToBeChecked~ does not belong to maze for unit Id~) Ew.Output~) Do
					);
					PosToBeChecked ias nil;
					PosToBeSet ias nil;
					OnMaze ias nil;
					(RightPosition (OnMaze~ PosToBeChecked~) In)~ Exe
 				);
				CheckGoalPositions ias (
					Correct ias true;
					T ias nil;
					RollbackGoals ias ();
					CheckGoal ias (
						(NotCorrectGoal true) ias (
							(Correct false)^
							((The goals Goals~ are invalid for unit Id~) Ew.Output~) Do
							(Goals RollbackGoals~)^
							($ doNothing)^
						);
						(NotCorrectGoal false) ias doNothing;
						(CheckPosition.PosToBeChecked $~)^
						(CheckPosition.PosToBeSet T)^
						(CheckPosition.OnMaze Ew.Maze.Nodes~)^
						((Checking CheckPosition.PosToBeChecked~) Ew.Output~) Do
						CheckPosition~ Exe
						(NotCorrectGoal (T~ nil) Ident)~ Exe
					);
					(Goals~ CheckGoal~) ForEach
				);
			);
		);
		Characters ias (
			/* general game unit */
			Unit ias (
				Properties ias (type attack defence);
				/* available unit's types  */
				Types ias (attacker defender);
				/* default type is attacker */
				Type ias attacker;
				Id ias nil;
				PlayerId ias nil;
				/* concrete unit */
				ConcreteUnit ias nil;
				/* unit's current position */
				CurrentPosition ias nil;
				/* true in case if unit should be stopped */
				StopUnit ias false;
				/* true in case if marked as killed, but not destroyed yet */
				MarkedAsKilled ias false;
				/* Performs initialization steps */
				Init ias (
					(Type attacker)^
					(ConcreteUnit nil)^
					(CurrentPosition nil)^
					(StopUnit false)^
					(MarkedAsKilled false)^
				);
				/* each unit has following properties: power of attack and defence */
				Power ias (
					Attack ias ();
					Defence ias ();
				);
				/* activates 'stay' command */
				Stay ias (CommandDispatcher.UnitCommandId stay)^;
				/* to be attacker */
				UnitAsAttacker ias (
					Create ias (
						(Attacker.Id Id~)^
						(Attacker.PlayerId PlayerId~)^
						(Attacker (Attacker Id~)) Born
						(ConcreteUnit Characters.(Attacker Id~))^
						LockAttackers [
							((Player PlayerId~)->(Units)->Attackers  
								((Player PlayerId~)->(Units)->Attackers~ (Id~)) Join
							)^
						LockAttackers ]
						((The attacker Id~ created and available attackers (Player PlayerId~)->(Units)->Attackers~) Ew.Output~) Do
					);
					Destroy ias (
						(NoAttackers true) ias doNothing;
						(NoAttackers false) ias (
							(PathFinder.PlayerId PlayerId~)^
							(PathFinder.FromUnit Id~)^
							PathFinder.UpdateUnitsSharedPath~ Exe
						);
						(NoRefreshPath true) ias doNothing;
						(NoRefreshPath false) ias (NoAttackers ((Player PlayerId~)->(Units)->Attackers~ ()) Ident)~ Exe;
						LockAttackers [
							((Player PlayerId~)->(Units)->Attackers  
								((Player PlayerId~)->(Units)->Attackers~ (Id~)) Substruct
							)^
							((The attacker Id~ destroyed and available attackers (Player PlayerId~)->(Units)->Attackers~) Ew.Output~) Do
							(NoRefreshPath (Player PlayerId~)->Stop~)~ Exe
						LockAttackers ]
					);
				);
				/* to be defender */
				UnitAsDefender ias (
					Create ias (
						(Defender.Id Id~)^
						(Defender.PlayerId PlayerId~)^
						(Defender (Defender Id~)) Born
						(ConcreteUnit Characters.(Defender Id~))^
						LockDefenders [
							( (Player PlayerId~)->(Units)->Defenders
								((Player PlayerId~)->(Units)->Defenders~ (Id~)) Join
							)^
						LockDefenders ]
						((The defender Id~ created and available defenders (Player PlayerId~)->(Units)->Defenders~) Ew.Output~) Do
					);
					Destroy ias (
						LockDefenders [
							( (Player PlayerId~)->(Units)->Defenders
								( (Player PlayerId~)->(Units)->Defenders~ (Id~) ) Substruct
							)^
							((The defender Id~ destroyed and available defenders (Player PlayerId~)->(Units)->Defenders~) Ew.Output~) Do
						LockDefenders ]
					);
				);
				/* sets unit's property  */
				PropertySetOperation ias (
					Prop ias nil;
					Value ias nil;
					(RightProp false) ias (
						((The unit Id~ can not set invalid property named by Prop~) Ew.Output~) Do
					);
					(RightProp true) ias (
						(Property type) ias (
							(Create attacker) ias UnitAsAttacker.Create~ Exe;
							(Create defender) ias UnitAsDefender.Create~ Exe;
							(Type Value~)^
							(Create Type~)~ Exe
							(ConcreteUnit~)->Init~ Exe
						);
						(Property attack) ias (
							(Power.Attack Value~)^
							((The unit Id~ has attack power Power.Attack~) Ew.Output~) Do
						);
						(Property defence) ias (
							(Power.Defence Value~)^
							((The unit Id~ has defence power Power.Defence~) Ew.Output~) Do
						);
						(Value ($~ 1) Get)^
						((The unit Id~ processes property Prop~ and value Value~) Ew.Output~) Do
						(Property Prop~)~ Exe
					);
					(Prop ($~ 0) Get)^
					((The unit Id~ received property Prop~) Ew.Output~) Do
					(RightProp (Properties~ Prop~) In)~ Exe 
				);
				GetCurrentPosition ias (
					(CurrentPositionNil true) ias (CurrentPosition (ConcreteUnit~)->(ActivityStrategy)->(Movement)->PrevState~)^;
					(CurrentPositionNil false) ias doNothing;
					(CurrentPosition (ConcreteUnit~)->(ActivityStrategy)->(Movement)->State~)^
					(CurrentPositionNil (CurrentPosition~ nil) Ident)~ Exe
				);
				/* unit receives commands in deferred manner */
				CommandQueue ias ();
				CommandDispatcher ias (
					Dispatch ias nil;
					LastUnitCommandId ias stay;
					UnitCommandId ias stay;
					UnitId ias nil;
					UnitCommandParams ias nil;

					(Handle stay) ias (
						UnitLifeStep~ Exe
					);
					(Handle stop) ias (
						((The unit Id~ received command stop) Ew.Output~) Do	
						(UnitCommandId stay)^
						UnitLifeStep~ Exe
					);
					(Handle go) ias (
						(ConcreteUnit~)->(ActivityStrategy)->(Movement)->CheckAndStart~ Exe
						UnitLifeStep~ Exe
					);
					(Handle movetopos) ias (
						(ConcreteUnit~)->(ActivityStrategy)->(Movement)->SetMoveToPos~ Exe
						UnitLifeStep~ Exe
					);
					(Handle startpos) ias (
						(ConcreteUnit~)->(ActivityStrategy)->(Movement)->SetStartPos~ Exe
						UnitLifeStep~ Exe
					);
					(Handle getpos) ias (
						UpdateCurrentPosition~ Exe
						((The unit Id~ has position CurrentPosition~) Ew.Output~) Do
						UnitLifeStep~ Exe
					);
					(Handle select) ias (
						(UnitCommandId LastUnitCommandId~)^
						UnitLifeStep~ Exe
					);
					(Handle setprops) ias (
						(UnitCommandParams~ PropertySetOperation~) ForEach
						UnitLifeStep~ Exe
					);
					(Handle kill) ias (
						(ConcreteUnit~)->(ActivityStrategy)->Kill~ Exe
						UnitLifeStep~ Exe
					);
					(NothingToDispatch true) ias doNothing;
					(NothingToDispatch false) ias (
						(LastUnitCommandId UnitCommandId~)^
						(UnitCommandId (Dispatch~ 1) Get)^
						(UnitId (Dispatch~ 2) Get)^
						(UnitCommandParams (Dispatch~ 3) Get)^
					);
					(NothingToDispatch (Dispatch~ nil) Ident)~ Exe
					(Handle UnitCommandId~)~ Exe
				);
				/* unit's lifestep */
				UnitLifeStep ias (
					(Stop false) ias (
						(emptyQ true) ias (
							(CommandDispatcher.Dispatch nil)^
						);
						(emptyQ false) ias (
							LockUnitCommandQueue [
								(CommandDispatcher.Dispatch (CommandQueue~) First)^
								(CommandQueue (CommandQueue~) Rest)^
							LockUnitCommandQueue ]
							((The unit Id~ received CommandDispatcher.Dispatch~) Ew.Output~) Do
						);
						(emptyQ (CommandQueue~ ()) Ident)~ Exe
						CommandDispatcher~ Exe
					);
					(Stop true) ias (
						((The unit Id~ stopped) Ew.Output~) Do
					);
					(Stop StopUnit~)~ Exe
				);

				lifeterm = (
					((The unit Id~ was born) Ew.Output~) Do
					Init~ Exe
					UnitLifeStep~ Exe
				) Exe
			);
		);
		Player ias (
			AvailableUnitsCommands ias (create destroy movetopos startpos go stop exit select setprops getpos kill);
			Id ias nil;
			Stop ias false;
			/* available units */
			Units ias (
				Attackers ias ();
				Defenders ias ();
			);
			StopAllUnits ias (
				CheckForUnitsCompletition ias (
					Check ias (CheckForUnits WaitForUnitsCompletitionLock [ (Units.Attackers~ ()) Ident (Units.Defenders~ ()) Ident WaitForUnitsCompletitionLock ])~ Exe;
					// wait for all units
					(CheckForUnits false false),(CheckForUnits true false),(CheckForUnits false true) ias Check~ Exe;
					(CheckForUnits true true) ias doNothing;
					Check~ Exe
				);
				StopUnits ias (
					StopUnit ias (
						(Services.(SignalUnit Player Id~)->PlayerId Id~)^
						(Services.(SignalUnit Player Id~)->To $~)^
						(Services.(SignalUnit Player Id~)->CommandId kill)^
						(Services.(SignalUnit Player Id~)->CommandParams ())^
						Services.(SignalUnit Player Id~)~ Exe
						((The player Id~ sent kill signal to unit $~) Ew.Output~) Do
					);
					($~ StopUnit~) ForEach
				);
				(Stop true)^
				((The player Id~ is going to be stopped) Ew.Output~) Do
				(CombinedUnits (Units.Attackers~ Units.Defenders~))^
				((The player Id~ sends kill signal to units CombinedUnits~) Ew.Output~) Do
				(CombinedUnits~ StopUnits~) ForEach
				((The player Id~ waits for units completition) Ew.Output~) Do
				CheckForUnitsCompletition~ Exe
				((The player Id~ all units finished) Ew.Output~) Do
			);
			PropagateCommandToUnit ias (
				LockUnitCommandQueue [
					(Characters.(Unit ($$)->(HandleUnitsCommand)->UnitId~)->CommandQueue
					(Characters.(Unit ($$)->(HandleUnitsCommand)->UnitId~)->CommandQueue~
						(
							(Id~ ($$)->(HandleUnitsCommand)->UnitCommandId~ ($$)->(HandleUnitsCommand)->UnitId~ ($$)->(HandleUnitsCommand)->UnitCommandParams~))
						) Join
					)^
				LockUnitCommandQueue ]
			);
			UnitsStateSetLocker ias nil;
			UnitsStateSet ias ();
			CommandQueue ias ();
			HandleUnitsCommand ias (
				UnitCommandId ias nil;
				UnitId ias nil;
				UnitCommandParams ias nil;
				(Handle create) ias (
					((The player Id~ creates unit UnitId~) Ew.Output~) Do
					(Characters.Unit.Id UnitId~)^
					(Characters.Unit.PlayerId Id~)^
					(Characters.Unit Characters.(Unit ($$)->(HandleUnitsCommand)->UnitId~)) Born
					(($$)->(HandleUnitsCommand)->UnitCommandParams~ Characters.(Unit ($$)->(HandleUnitsCommand)->UnitId~)->PropertySetOperation~) ForEach
					PlayerLifeStep~ Exe
				);
				(Handle movetopos),(Handle startpos),(Handle go),(Handle stop),(Handle select),(Handle setprops),(Handle getpos),(Handle kill) ias (
					PropagateCommandToUnit~ Exe
					PlayerLifeStep~ Exe
				);
                                (Handle destroy) ias (
					((The player Id~ executes other actions) Ew.Output~) Do
					PlayerLifeStep~ Exe
				);
				(UnitCommandId (CommandDispatcher.Dispatch~ 0) Get)^
				(UnitId (CommandDispatcher.Dispatch~ 1) Get)^
				(UnitCommandParams (CommandDispatcher.Dispatch~ 2) Get)^
				(Handle UnitCommandId~)~ Exe
			);
			CommandDispatcher ias (
				Dispatch ias nil;
				(RightCommand true) ias (
					HandleUnitsCommand~ Exe
				);
				(RightCommand false) ias (
					PlayerLifeStep~ Exe
				);
				((The player Id~ received command Dispatch~ to dispatch) Ew.Output~) Do
				(RightCommand (AvailableUnitsCommands~ (Dispatch~ 0) Get) In)~ Exe
			);
			/* Player's lifestep */
			PlayerLifeStep ias (
				(Stop false) ias (
					(emptyQ true) ias (
						PlayerLifeStep~ Exe
					);
					(emptyQ false) ias (
						LockQueue [
							(CommandDispatcher.Dispatch (CommandQueue~) First)^
							(CommandQueue (CommandQueue~) Rest)^
						LockQueue ]
						CommandDispatcher~ Exe
					);
					(emptyQ (CommandQueue~ ()) Ident)~ Exe
				);
				(Stop true) ias (
					StopAllUnits~ Exe
					((The player Id~ stopped) Ew.Output~) Do
				);
				(Stop StopTheWorld~)~ Exe
			);
			lifeterm = (
				((The player Id~ added and active) Ew.Output~) Do
				(Services.SignalUnit Services.(SignalUnit Player Id~)) Born
				PlayerLifeStep~ Exe
			) Exe
		);
		Manager ias (
			Command ias nil;
			Character ias nil;
			Id ias nil;
			UnitId ias nil;
			CommandId ias nil;
			Params ias nil;

			StopAll ias (AutoCommands.Injection (AutoCommands.Injection~ ((manager 0 exit))) Join)^;
			/* command is propagated to player */
			PropagateCommand ias (
				LockQueue [
					((Player Id~)->CommandQueue ((Player Id~)->CommandQueue~ ((CommandId~ UnitId~ Params~))) Join)^
				LockQueue ]
				((Command propagated to player Id~) Ew.Output~) Do
			);
			(ManagerCommand true) ias (
				(Command playeradd) ias (
					(Player.Id UnitId~)^
					(Player.Stop false)^
					(Player.Units.Attackers ())^
					(Player.Units.Defenders ())^
					(Player (Player UnitId~)) Born
				);
				(Command exit) ias (
					(StopTheWorld true)^
				);
				((manager command CommandId~) Ew.Output~) Do
				(Command CommandId~)~ Exe
			);
			(ManagerCommand false) ias (
				((Not manager command propagating) Ew.Output~) Do
				/* passes for processing */
				PropagateCommand~ Exe
			);
			/* main loop where model waits for incoming commands and dispatches them */
			MainLoop ias (
				/* decomposes incoming command */
				ParseIncomingCommand ias (
					(Character (Command~ 0) Get)^
					(Id (Command~ 1) Get)^
					(CommandId (Command~ 2) Get)^
					(UnitId (Command~ 3) Get)^
					(Params (Command~ 4) Get)^
				);
				(Stop false) ias (
					(WaitForCommand true) ias (
						(NoAutoCommand false) ias (
							(Command (AutoCommands.Injection~) First)^
							(AutoCommands.Injection (AutoCommands.Injection~) Rest)^
							((The auto command Command~) Ew.Output~) Do
							ParseIncomingCommand~ Exe
							((The auto command Command~ character Character~) Ew.Output~) Do
							(ManagerCommand (Character~ manager) Ident)~ Exe
						);
						(NoAutoCommand true) ias doNothing;
						(NoAutoCommand (AutoCommands.Injection~ ()) Ident)~ Exe
						MainLoop~ Exe
					);
					(WaitForCommand false) ias (
						ParseIncomingCommand~ Exe
						(ManagerCommand (Character~ manager) Ident)~ Exe
						MainLoop~ Exe
					);
					/* waiting for command, in non-blocking manner */ 
					(Command (() Ew.Input~) Do)^
					(WaitForCommand (Command~ nil) Ident)~ Exe
				);
				(Stop true) ias (
					((The manager stopped) Ew.Output~) Do
				);
				(Stop StopTheWorld~)~ Exe
			);

			source lifeterm = (
				((The initialization time) Ew.Output~) Do
				3000 Relax
				((The game manager started and loads maze) Ew.Output~) Do
				Ew.Maze~ Exe
				((The game manager waits for commands) Ew.Output~) Do
				MainLoop~ Exe
				3000 Relax
			) Exe
		);

		AutoCommands ias (
			Injection ias (
				(manager 0 playeradd 0)
				(player 0 create 0 ( (type attacker)
						     (attack (yes yes yes))
						     (defence (no no yes))
						   ))
				(player 0 startpos 0 (0 39))
				(player 0 movetopos 0 ((17 10)))
				(player 0 go 0)

				(player 0 create 1 ( (type attacker)
						     (attack (yes yes yes))
						     (defence (no no yes))
						   ))
				(player 0 startpos 1 (5 39))
				(player 0 movetopos 1 ((17 10)))
				(player 0 go 1)
	
				(player 0 create 2 ( (type defender)
						     (attack (yes yes no))
						     (defence (yes yes yes yes))
						    ))
				(player 0 startpos 2 (15 29))
				(player 0 go 2)

			);
		);
	);
}
