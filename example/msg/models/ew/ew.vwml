module ExternalWorld {
	Ew ias (
		BattleField ias (
			AttackZone ias nil;
			AttackZoneCtx ias nil;
			DefenceZone ias nil;
			DefenceZoneCtx ias nil;
			MainZone ias nil;
			MainZoneCtx ias nil;
			Prototype ias (
				Stg ias nil;
				Ctx ias nil;
				(Node ($~ 0) Get)^
				(LinkedNodes ($~ 1) Get)^
				(Node~ Ctx~ true) Context
				(Node~ LinkedNodes~)^
				(Stg~ (Stg~~ (Node~)) Join)^
#if (verbose)
				((Connecting Node~ with LinkedNodes~ and list of nodes Stg~~ on context Ctx~) Ew.Output~) Do
#endif
			);
			BuildMainZone ias (
				(Prototype.Stg MainZone~)^
				(Prototype.Ctx MainZoneCtx~)^
				Prototype~ Exe
			);
			// attack firezones
			BuildAttackFireZone ias (
				(Prototype.Stg AttackZone~)^
				(Prototype.Ctx AttackZoneCtx~)^
				Prototype~ Exe
			);
			// defence firezone
			BuildDefenceFireZone ias (
				(Prototype.Stg DefenceZone~)^
				(Prototype.Ctx DefenceZoneCtx~)^
				Prototype~ Exe
			);
			Initial ias (	(battleField BuildMainZone)
					(attackFireZoneField BuildAttackFireZone)  
					(defenceFireZoneField BuildDefenceFireZone)
				);
			/* builds: battlefield, atackers' firezone, defenders' firezone */
			Build ias (
				Builder ias ((((($~ 0) Get) Ew.LoadGraph~) Do) ($~ 1) Get ~) ForEach;
				(Initial~ Builder~) ForEach
			);
		);
		PlayerAccountConf ias (
			/* initial quartals (closed) per player */
			QuartalsPerPlayer ias 1;
			/* available resource types and their initial value */
			ResourceTypes ias ((QuartalsPerPlayer 1)((vodka 10000) (gold 20000) (food 300000)));
			// dynamic load configuration
			Load ias (
				Conf ias nil;
				(NotReady true) ias doNothing;
				(NotReady false) ias (
					(QuartalsPerPlayer ((Conf~ 0) Get 1) Get)^
					(ResourceTypes (Conf~ 1) Get)^
				);
				(NotReady (Conf~ nil) Ident)~ Exe
#if (verbose)
				((The player account configuration is ResourceTypes~ and  QuartalsPerPlayer is QuartalsPerPlayer~) Ew.Output~) Do
#endif
			);
			Load~ Exe
		);
		/*
			Loaded quartal configuration:
			(
				(SherifBribeRanges (100 200 300 100 200 400 500 100 200 100 100 50 10 20 40))
				(Resources ((vodka 100 500 12 3000 100) (gold 10 500 10 4000 70) (food 50 500 9 5000 50)))
			)
		*/
		QuartalsConf ias (
			ConfFields ias (SherifBribeRanges Resources);
			// dynamic load configuration
			Load ias (
				Conf ias nil;
				ConfIndex ias 0;
				ApplyConf ias (
					SetConfField ias (
						($~ ((Conf~ ConfIndex~) Get 1) Get)^
						($~ QuartalsConf true) Context
						(ConfIndex ((ConfIndex~) Ew.IncValue~) Do)^
					);
					(ConfIndex 0)^
					(ConfFields~ SetConfField~) ForEach 
				);
				(NotReady true) ias doNothing;
				(NotReady false) ias ApplyConf~ Exe;
				(NotReady (Conf~ nil) Ident)~ Exe
			);
			/* selected per quartal in random way */
			SherifBribeRanges ias (100 200 300 100 200 400 500 100 200 100 100 50 10 20 40);
			/* available quartal's resources */
			/*
				index:
					0 => type
					1 => quantum (payment per period)
					2 => period
					3 => number of payment's periods
					4 => quartal's open time
					5 => minimal resource's quantum when sherif agrees to open information about quartal

			 */
			Resources ias ((vodka 100 500 12 3000 100) (gold 10 500 10 4000 70) (food 50 500 9 5000 50));
			// loads if exists
			Load~ Exe
#if (verbose)
			((The quartals configuration is) Ew.Output~) Do
			ShowField ias (($~ $~~) Ew.Output~) Do;
			(ConfFields~ ShowField~) ForEach
#endif
		);

		CharactersConf ias (
			/*
				index:
					0 => resource type
					1 => quantum of resources needed to hire one character
					2 => time (in ms) needed to hire one character
			*/
			skeleton ias (vodka 500 10000);
			zombac ias (gold 100 3000);
			vampire ias (food 1000 20000);
		);

		BusinessConf ias (
			Conf ias nil;
			Factors ias ();
#if (business)
			AvailableResources ias nil;
			GDevelop ias 0;
			GContain ias 0;
			UnitsInfo ias ();
			LH ias nil;
			Cashier ias nil;
			ConfFields ias (AvailableResources Factors GDevelop GContain UnitsInfo LH Cashier);
#else
			ConfFields ias (Factors);
#endif
			// dynamic load configuration
			Load ias (
				Conf ias nil;
				ConfIndex ias 0;
				ApplyConf ias (
					SetConfField ias (
						($~ ((Conf~ ConfIndex~) Get 1) Get)^
						($~ BusinessConf true) Context
						(ConfIndex ((ConfIndex~) Ew.IncValue~) Do)^
					);
					(ConfIndex 0)^
					(ConfFields~ SetConfField~) ForEach 
				);
				(NotReady true) ias doNothing; 
				(NotReady false) ias ApplyConf~ Exe;
				(NotReady (Conf~ nil) Ident)~ Exe
			);
			Load~ Exe
#if (verbose)
	#if (business)
			((The business configuration is AvailableResources~ and Factors~ and GDevelop~ and GContain~ and UnitsInfo~ and LH~ and Cashier~) Ew.Output~) Do
	#else
			((The business configuration is Factors~) Ew.Output~) Do
	#endif
#endif
		);

		// loads garage's configuration
		GarageConf ias (
			Conf ias nil;
			Garage ias nil;
			ConfFields ias (Garage);
			// dynamic load configuration
			Load ias (
				Conf ias nil;
				ConfIndex ias 0;
				ApplyConf ias (
					SetConfField ias (
						($~ ((Conf~ ConfIndex~) Get 1) Get)^
						($~ GarageConf true) Context
						(ConfIndex ((ConfIndex~) Ew.IncValue~) Do)^
					);
					(ConfIndex 0)^
					(ConfFields~ SetConfField~) ForEach 
				);
				(NotReady true) ias doNothing; 
				(NotReady false) ias ApplyConf~ Exe;
				(NotReady (Conf~ nil) Ident)~ Exe
			);
			Load~ Exe
#if (verbose)
			((The garage configuration is Garage~) Ew.Output~) Do
#endif
		);

		TargetsToBeDestroyed ias ((17 10));
		ConfiguredNumOfRequestedSteps ias 4;
		Input ias communication.in.read;
		Output ias communication.in.write;
		BlockInput ias communication.in.block;
		UnblockInput ias communication.in.unblock;
#if (standalone)
		InChannel ias communication.in.read;
		OutChannel ias communication.in.write;
		InChannelBlockInput ias communication.in.block;
		InChannelUnblockInput ias communication.in.unblock;
#else
		InChannel ias communication.strategyfringe.read;
		OutChannel ias communication.strategyfringe.write;
		InChannelBlockInput ias communication.strategyfringe.block;
		InChannelUnblockInput ias communication.strategyfringe.unblock;
#endif
		IncValue ias services.math.inc;
		DecValue ias services.math.dec;
		Sum ias services.math.sum;
		Sub ias services.math.substr;
		SumF ias services.math.sumf;
		SubF ias services.math.substrf;
		Mul ias services.math.mult;
		Compare ias services.math.compare;
		CompareF ias services.math.comparef;
		RecalcQuantum ias services.economic.recalcquantum;
#if (business)
		RecalcBattleResult ias services.economic.recalcbattleresult;
		RecalcCompensation ias services.economic.recalccompensation;
#endif
		LoadGraph ias services.graph.load;
		LoadConf ias services.configuration.load;

		LoadConfiguration ias (
			(PlayerAccountConf.Load.Conf ((accountconf) Ew.LoadConf~) Do)^
			PlayerAccountConf~ Exe
			(QuartalsConf.Load.Conf ((quartalconf) Ew.LoadConf~) Do)^
			QuartalsConf~ Exe
			(BusinessConf.Load.Conf ((businessconf) Ew.LoadConf~) Do)^
			BusinessConf~ Exe
			(GarageConf.Load.Conf ((garageconf) Ew.LoadConf~) Do)^
			GarageConf~ Exe
		);
	);
}
