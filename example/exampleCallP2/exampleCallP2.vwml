options {
	language=__java__ {
  		package = "com.win.game.maze.model.vwml.exampleCallP2"
  		path = "c:\var\vwml/exampleCallP2/src"
  		author = "Groozman M.Z."
		project_name = "exampleCallP2Proj"
  		description = "Example of CallP operation usage"
		beyond {
			fringe communication ias (
				out ias "com.win.game.model.fringe.gate.async.console.AsyncConsole"
				in ias "com.win.game.model.fringe.gate.async.console.AsyncConsole"
			)
			fringe services ias (
				math ias "com.vw.lang.beyond.java.fringe.gate.math.Math"
			)
		}
		conflictring {
			"{MagicWorld.Manager}.PropagateCommand.LockQueue" conflicts (
				"{MagicWorld.Player}.PlayerLifeStep.(emptyQ false).LockQueue"
			)
		}
	}
}

include "../algorithms/DpfB/DpfB.vwml"

module exampleCallP2 {
	Ew ias (
		/* maze */
		Maze ias (
			(1 3) (1 4) (1 5)
			(2 1) (2 2) (2 3) (2 5)
			(3 1) (3 3) (3 4) (3 5)
			(4 1) (4 3)
			(5 1) (5 2) (5 3) (5 4) (5 5)
		);
		DeltaMovement ias (
			(-1 0) (0 -1)
			(0 1) (1 0)
		);
		Input ias communication.in.read;
		Output ias communication.in.write;
		VSum ias services.math.vsum;
	);
	MagicWorld ias (
		Characters ias (
			/* simple game unit */
			Unit ias (
				Id ias nil;
				/* movement's parameters */
				Movement ias (
					Goals ias ();
					ChoiceSet ias ();
					NextStates ias ();
					StateSet ias ();
					SeqStates ias ();
					State ias nil;
					PrevState ias nil;
					Init ias true;
					PathPassed ias false;

					Result ias (
						((The result is SeqStates~) Ew.Output~) Do
						(PathPassed true)^
						(Init true)^
					);

					CheckPosition ias (
						(RightPosition true) ias (
							(PosToBeSet~ PosToBeChecked~)^
							((The unit Id~ received pos PosToBeSet~~) Ew.Output~) Do
						);
						(RightPosition false) ias (
							((The pos PosToBeChecked~ does not belong to maze for unit Id~) Ew.Output~) Do
						);
						PosToBeChecked ias nil;
						PosToBeSet ias nil;
						(RightPosition (Ew.Maze~ PosToBeChecked~) In)~ Exe
 					);
				);
				/* unit receives commands in deferred manner */
				CommandQueue ias ();
				CommandDispatcher ias (
					Dispatch ias nil;
					UnitCommandId ias stay;
					UnitId ias nil;
					UnitCommandParams ias nil;

					(Handle exit) ias doNothing;
					(Handle stay) ias (
						UnitLifeStep~ Exe
					);
					(Handle stop) ias (
						((The unit Id~ received command stop) Ew.Output~) Do	
						(UnitCommandId stay)^
						UnitLifeStep~ Exe
					);
					(Handle go) ias (
						// start movement, all parameters are correct
						(CheckMovementStart false false) ias (
							(Init false) ias 2000 Relax;
							(Init true) ias (
								(Movement.PrevState nil)^
								(Movement.SeqStates (Movement.State~))^
								(Movement.StateSet (Movement.State~))^
								(Movement.Init false)^
								((The unit Id~ initialized movement procedure) Ew.Output~) Do
							);
							(Init Movement.Init~)~ Exe
							(Movement.PrevState Movement.State~)^ 
							((Ew.Maze Ew.DeltaMovement
								  Movement.Goals
								  Movement.State
								  Movement.ChoiceSet
								  Movement.StateSet
								  Movement.SeqStates
								  Ew.VSum
								  Movement.Result) DpfSearchMkB~) CallP
							((The unit Id~ moved from Movement.PrevState~ to Movement.State~) Ew.Output~) Do
						);
						// not all parameters were set, movement impossible
						(CheckMovementStart true true),(CheckMovementStart false true),(CheckMovementStart true true) ias (
							(UnitCommandId stay)^
							((Incorrect parameters (Movement.Goals~ Movement.State~) for movement unit Id~) Ew.Output~) Do
						);
						(CheckMovementStart (Movement.Goals~ ()) Ident (Movement.State~ nil) Ident)~ Exe
						UnitLifeStep~ Exe
					);
					(Handle movetopos) ias (
						(Movement.CheckPosition.PosToBeChecked UnitCommandParams~)^
						(Movement.CheckPosition.PosToBeSet Movement.Goals)^
                                                Movement.CheckPosition~ Exe
						(UnitCommandId stay)^
						UnitLifeStep~ Exe
					);
					(Handle startpos) ias (
						(Movement.CheckPosition.PosToBeChecked UnitCommandParams~)^
						(Movement.CheckPosition.PosToBeSet Movement.State)^
                                                Movement.CheckPosition~ Exe
						(UnitCommandId stay)^
						UnitLifeStep~ Exe
					);
					(NothingToDispatch true) ias doNothing;
					(NothingToDispatch false) ias (
						(UnitCommandId (Dispatch~ 0) Get)^
						(UnitId (Dispatch~ 1) Get)^
						(UnitCommandParams (Dispatch~ 2) Get)^
					);
					(NothingToDispatch (Dispatch~ nil) Ident)~ Exe
					(Handle UnitCommandId~)~ Exe
				);
				/* unit's lifestep */
				UnitLifeStep ias (
					(emptyQ true) ias (
						(CommandDispatcher.Dispatch nil)^
					);
					(emptyQ false) ias (
						(CommandDispatcher.Dispatch (CommandQueue~) First)^
						(CommandQueue (CommandQueue~) Rest)^
						((The unit Id~ received CommandDispatcher.Dispatch~) Ew.Output~) Do
					);
					(emptyQ (CommandQueue~ ()) Ident)~ Exe
					CommandDispatcher~ Exe
				);

				lifeterm = (
					((The unit Id~ was born) Ew.Output~) Do
					UnitLifeStep~ Exe
				) Exe
			);
		);
		Player ias (
			AvailableUnitsCommands ias (create destroy movetopos startpos go stop exit);
			Id ias nil;
			CommandQueue ias ();
			HandleUnitsCommand ias (
				UnitCommandId ias nil;
				UnitId ias nil;
				UnitCommandParams ias nil;
				(Handle create) ias (
					(Characters.Unit.Id UnitId~)^
					((The player Id~ creates unit UnitId~) Ew.Output~) Do
					(Characters.Unit Characters.(Unit ($$)->(HandleUnitsCommand)->UnitId~)) Born
					PlayerLifeStep~ Exe
				);
				(Handle movetopos),(Handle startpos),(Handle go),(Handle stop) ias (
					(Characters.(Unit ($$)->(HandleUnitsCommand)->UnitId~)->CommandQueue
					(Characters.(Unit ($$)->(HandleUnitsCommand)->UnitId~)->CommandQueue~
						    (
							(($$)->(HandleUnitsCommand)->UnitCommandId~ ($$)->(HandleUnitsCommand)->UnitId~ ($$)->(HandleUnitsCommand)->UnitCommandParams~))
						    ) Join
					)^
					PlayerLifeStep~ Exe
				);
                                (Handle destroy) ias (
					((The player Id~ executes other actions) Ew.Output~) Do
					PlayerLifeStep~ Exe
				);
				(UnitCommandId (CommandDispatcher.Dispatch~ 0) Get)^
				(UnitId (CommandDispatcher.Dispatch~ 1) Get)^
				(UnitCommandParams (CommandDispatcher.Dispatch~ 2) Get)^
				(Handle UnitCommandId~)~ Exe
			);
			CommandDispatcher ias (
				Dispatch ias nil;
				(RightCommand true) ias (
					HandleUnitsCommand~ Exe
				);
				(RightCommand false) ias (
					PlayerLifeStep~ Exe
				);
				((The player Id~ received command Dispatch~ to dispatch) Ew.Output~) Do
				(RightCommand (AvailableUnitsCommands~ (Dispatch~ 0) Get) In)~ Exe
			);
			/* Player's lifestep */
			PlayerLifeStep ias (
				(emptyQ true) ias (
					PlayerLifeStep~ Exe
				);
				(emptyQ false) ias (
					LockQueue [
						(CommandDispatcher.Dispatch (CommandQueue~) First)^
						(CommandQueue (CommandQueue~) Rest)^
					LockQueue ]
					CommandDispatcher~ Exe
				);
				(emptyQ (CommandQueue~ ()) Ident)~ Exe
			);
			lifeterm = (
				((The player Id~ added and active) Ew.Output~) Do
				PlayerLifeStep~ Exe
			) Exe
		);
		Manager ias (
			Character ias nil;
			Id ias nil;
			UnitId ias nil;
			CommandId ias nil;
			Params ias nil;
			/* command is propagated to player */
			PropagateCommand ias (
				LockQueue [
					((Player Id~)->CommandQueue ((Player Id~)->CommandQueue~ ((CommandId~ UnitId~ Params~))) Join)^
				LockQueue ]
				((Command propagated to player Id~) Ew.Output~) Do
			);
			(ManagerCommand true) ias (
				(Command playeradd) ias (
					(Player.Id UnitId~)^
					(Player (Player UnitId~)) Born
				);
				((manager command CommandId~) Ew.Output~) Do
				(Command CommandId~)~ Exe
			);
			(ManagerCommand false) ias (
				((Not manager command propagating) Ew.Output~) Do
				/* passes for processing */
				PropagateCommand~ Exe
			);
			/* main loop where model waits for incoming commands and dispatches them */
			MainLoop ias (
				(WaitForCommand true) ias (
					MainLoop~ Exe
				);
				(WaitForCommand false) ias (
					/* decomposes incoming command */
					(Character (Command~ 0) Get)^
					(Id (Command~ 1) Get)^
					(CommandId (Command~ 2) Get)^
					(UnitId (Command~ 3) Get)^
					(Params (Command~ 4) Get)^
					(ManagerCommand (Character~ manager) Ident)~ Exe
					MainLoop~ Exe
				);
				/* waiting for command, in non-blocking manner */ 
				(Command (() Ew.Input~) Do)^
				(WaitForCommand (Command~ nil) Ident)~ Exe
			);	

			source lifeterm = (
				((The game manager started and waits for commands) Ew.Output~) Do
				MainLoop~ Exe
				3000 Relax
			) Exe
		);
	);
}
